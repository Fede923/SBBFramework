  /* play the game! */
  while( fgets( line, MAX_LINE_LEN, fromServer ) ) {

    /* ignore comments */
    if( line[ 0 ] == '#' || line[ 0 ] == ';' ) {
      continue;
    }

    len = readMatchState( line, game, &state );
    if( len < 0 ) {

      fprintf( stderr, "ERROR: could not read state %s", line );
      exit( EXIT_FAILURE );
    }

    if( stateFinished( &state.state ) ) {
      /* ignore the game over message */

      continue;
    }

    if( currentPlayer( game, &state.state ) != state.viewingPlayer ) {
      /* we're not acting */

      continue;
    }

    /* add a colon (guaranteed to fit because we read a new-line in fgets) */
    line[ len ] = ':';
    ++len;

    /* build the set of valid actions */
    p = 0;
    for( a = 0; a < NUM_ACTION_TYPES; ++a ) {

      actionProbs[ a ] = 0.0;
    }

    /* consider fold */
    action.type = a_fold;
    action.size = 0;
    if( isValidAction( game, &state.state, 0, &action ) ) {

      actionProbs[ a_fold ] = probs[ a_fold ];
      p += probs[ a_fold ];
    }

    /* consider call */
    action.type = a_call;
    action.size = 0;
    actionProbs[ a_call ] = probs[ a_call ];
    p += probs[ a_call ];

    /* consider raise */
    if( raiseIsValid( game, &state.state, &min, &max ) ) {

      actionProbs[ a_raise ] = probs[ a_raise ];
      p += probs[ a_raise ];
    }

    /* normalise the probabilities  */
    assert( p > 0.0 );
    for( a = 0; a < NUM_ACTION_TYPES; ++a ) {

      actionProbs[ a ] /= p;
    }

    /* choose one of the valid actions at random */
    p = genrand_real2( &rng );
    for( a = 0; a < NUM_ACTION_TYPES - 1; ++a ) {

      if( p <= actionProbs[ a ] ) {

        break;
      }
      p -= actionProbs[ a ];
    }
    action.type = (enum ActionType)a;
    if( a == a_raise ) {

      action.size = min + genrand_int32( &rng ) % ( max - min + 1 );
    }

    /* do the action! */
    assert( isValidAction( game, &state.state, 0, &action ) );
    r = printAction( game, &action, MAX_LINE_LEN - len - 2,
             &line[ len ] );
    if( r < 0 ) {

      fprintf( stderr, "ERROR: line too long after printing action\n" );
      exit( EXIT_FAILURE );
    }
    len += r;
    line[ len ] = '\r';
    ++len;
    line[ len ] = '\n';
    ++len;

    if( fwrite( line, 1, len, toServer ) != len ) {

      fprintf( stderr, "ERROR: could not get send response to server\n" );
      exit( EXIT_FAILURE );
    }
    fflush( toServer );
  }


uint8_t currentPlayer( const Game *game, const State *state )
{
  /* if action has already been made, compute next player from last player */
  if( state->numActions[ state->round ] ) {
    return nextPlayer( game, state, state->actingPlayer[ state->round ]
           [ state->numActions[ state->round ] - 1 ] );
  }

  /* first player in a round is determined by the game and round
     use nextPlayer() because firstPlayer[round] might be unable to act */
  return nextPlayer( game, state, game->firstPlayer[ state->round ]
         + game->numPlayers - 1 );
}



int readMatchState( const char *string, const Game *game,
            MatchState *state )
{
  int c, r;

  /* HEADER = MATCHSTATE:player */
  if( sscanf( string, "MATCHSTATE:%"SCNu8"%n",
          &state->viewingPlayer, &c ) < 1
      || state->viewingPlayer >= game->numPlayers )  {
    return -1;
  }

  /* read rest of state */
  r = readStateCommon( &string[ c ], game, &state->state );
  if( r < 0 ) {
    return -1;
  }
  c += r;

  return c;
}



static int readStateCommon( const char *string, const Game *game,
                State *state )
{
  uint32_t handId;
  int c, r;

  /* HEADER */
  c = 0;

  /* HEADER:handId */
  if( sscanf( string, ":%"SCNu32"%n", &handId, &r ) < 1 ) {
    return -1;
  }
  c += r;

  initState( game, handId, state );

  /* HEADER:handId: */
  if( string[ c ] != ':' ) {
    return -1;
  }
  ++c;

  /* HEADER:handId:betting: */
  r = readBetting( &string[ c ], game, state );
  if( r < 0 ) {
    return -1;
  }
  c += r;

  /* HEADER:handId:betting:holeCards */
  r = readHoleCards( &string[ c ], game, state );
  if( r < 0 ) {
    return -1;
  }
  c += r;

  /* HEADER:handId:betting:holeCards boardCards */
  r = readBoardCards( &string[ c ], game, state );
  if( r < 0 ) {
    return -1;
  }
  c += r;

  return c;
}





void initState( const Game *game, const uint32_t handId, State *state )
{
  int p, r;

  state->handId  = handId;

  state->maxSpent = 0;
  for( p = 0; p < game->numPlayers; ++p ) {

    state->spent[ p ] = game->blind[ p ];
    if( game->blind[ p ] > state->maxSpent ) {

      state->maxSpent = game->blind[ p ];
    }
  }

  if( game->bettingType == noLimitBetting ) {
    /* no-limit games need to keep track of the minimum bet */

    if( state->maxSpent ) {
      /* we'll have to call the big blind and then raise by that
     amount, so the minimum raise-to is 2*maximum blinds */

      state->minNoLimitRaiseTo = state->maxSpent * 2;
    } else {
      /* need to bet at least one chip, and there are no blinds/ante */

      state->minNoLimitRaiseTo = 1;
    }
  } else {
    /* no need to worry about minimum raises outside of no-limit games */

    state->minNoLimitRaiseTo = 0;
  }

  for( p = 0; p < game->numPlayers; ++p ) {

    state->spent[ p ] = game->blind[ p ];

    if( game->blind[ p ] > state->maxSpent ) {
      state->maxSpent = game->blind[ p ];
    }

    state->playerFolded[ p ] = 0;
  }

  for( r = 0; r < game->numRounds; ++r ) {

    state->numActions[ r ] = 0;
  }

  state->round = 0;

  state->finished = 0;
}




/* read actions from a string, updating state with the actions
   reading is terminated by '\0' and ':'
   returns number of characters consumed, or -1 on failure
   state will be modified, even on failure */
static int readBetting( const char *string, const Game *game, State *state )
{
  int c, r;
  Action action;

  c = 0;
  while( 1 ) {

    if( string[ c ] == 0 ) {
      break;
    }

    if( string[ c ] == ':' ) {
      ++c;
      break;
    }

    /* ignore / character */
    if( string[ c ] == '/' ) {
      ++c;
      continue;
    }

    r = readAction( &string[ c ], game, &action );
    if( r < 0 ) {
      return -1;
    }

    if( !isValidAction( game, state, 0, &action ) ) {
      return -1;
    }

    doAction( game, &action, state );
    c += r;
  }

  return c;
}



int readAction( const char *string, const Game *game, Action *action )
{
  int c, r;

  action->type = charToAction[ (uint8_t)string[ 0 ] ];
  if( action->type < 0 ) {
    return -1;
  }
  c = 1;

  if( action->type == a_raise && game->bettingType == noLimitBetting ) {
    /* no-limit bet/raise needs to read a size */

    if( sscanf( &string[ c ], "%"SCNd32"%n", &action->size, &r ) < 1 ) {
      return -1;
    }
    c += r;
  } else {
    /* size is zero for anything but a no-limit raise */

    action->size = 0;
  }

  return c;
}





int isValidAction( const Game *game, const State *curState,
           const int tryFixing, Action *action )
{
  int min, max, p;

  if( stateFinished( curState ) || action->type == a_invalid ) {
    return 0;
  }

  p = currentPlayer( game, curState );

  if( action->type == a_raise ) {

    if( !raiseIsValid( game, curState, &min, &max ) ) {
      /* there are no valid raise sizes */

      return 0;
    }

    if( game->bettingType == noLimitBetting ) {
      /* no limit games have a size */

      if( action->size < min ) {
    /* bet size is too small */

    if( !tryFixing ) {

      return 0;
    }
    fprintf( stderr, "WARNING: raise of %d increased to %d\n",
         action->size, min );
    action->size = min;
      } else if( action->size > max ) {
    /* bet size is too big */

    if( !tryFixing ) {

      return 0;
    }
    fprintf( stderr, "WARNING: raise of %d decreased to %d\n",
         action->size, max );
    action->size = max;
      }
    } else {

    }
  } else if( action->type == a_fold ) {

    if( curState->spent[ p ] == curState->maxSpent
    || curState->spent[ p ] == game->stack[ p ] ) {
      /* player has already called all bets, or is all-in */

      return 0;
    }

    if( action->size != 0 ) {

      fprintf( stderr, "WARNING: size given for fold\n" );
      action->size = 0;
    }
  } else {
    /* everything else */

    if( action->size != 0 ) {

      fprintf( stderr, "WARNING: size given for something other than a no-limit raise\n" );
      action->size = 0;
    }
  }

  return 1;
}





static int readHoleCards( const char *string, const Game *game,
              State *state )
{
  int p, c, r, num;

  c = 0;
  for( p = 0; p < game->numPlayers; ++p ) {

    /* check for player separator '|' */
    if( p != 0 ) {
      if( string[ c ] == '|' ) {
    ++c;
      }
    }

    num = readCards( &string[ c ], game->numHoleCards,
             state->holeCards[ p ], &r );
    if( num == 0 ) {
      /* no cards for player p */

      continue;
    }
    if( num != game->numHoleCards ) {
      /* read some cards, but not enough - bad! */

      return -1;
    }
    c += r;
  }

  return c;
}




static int readBoardCards( const char *string, const Game *game,
               State *state )
{
  int i, c, r;

  c = 0;
  for( i = 0; i <= state->round; ++i ) {

    /* check for round separator '/' */
    if( i != 0 ) {
      if( string[ c ] == '/' ) {
    ++c;
      }
    }

    if( readCards( &string[ c ], game->numBoardCards[ i ],
           &state->boardCards[ bcStart( game, i ) ], &r )
    != game->numBoardCards[ i ] ) {
      /* couldn't read the required number of cards - bad! */

      return -1;
    }
    c += r;
  }

  return c;
}





int readCards( const char *string, const int maxCards,
         uint8_t *cards, int *charsConsumed )
{
  int i, c, r;

  c = 0;
  for( i = 0; i < maxCards; ++i ) {

    r = readCard( &string[ c ], &cards[ i ] );
    if( r < 0 ) {
      break;
    }
    c += r;
  }

  *charsConsumed = c;
  return i;
}